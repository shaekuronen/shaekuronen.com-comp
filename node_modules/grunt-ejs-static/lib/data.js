
module.exports = exports = {

  // parse data
  parse_data: function(ejs_static) {

    var grunt = ejs_static.grunt;

    data_validator(ejs_static);

    // PRIVATE FUNCTIONS
    // 

    function data_validator(ejs_static) {

      // get data specified in ejs_static options
      if (ejs_static.options.path_to_data) {

        var data = grunt.file.readJSON(ejs_static.options.path_to_data);

        // parse the data
        parse_data_files(data);

        grunt.log.debug('Data successfully imported');
        
      } else {

        grunt.fail.warn('The path_to_data option is required, please specify in Gruntfile');
        return false;

      }
      // end get data specified in ejs_static options

    }

    // iterate through items in data file
    // http://stackoverflow.com/questions/7440001/iterate-over-object-keys-in-node-js
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
    function parse_data_files(data_object) {

      Object.keys(data_object).forEach(function(key) {

        path_to_layout_validator(key, data_object);

      });

    }
    // end iterate through items in data file

    // search the layouts dir for a dir or file that matches key
    function search_layouts_dir(key) {

      var search_pattern1 = ejs_static.path.join(ejs_static.options.path_to_layouts, '**', key + '.ejs');
      grunt.log.debug('search pattern1 is ' + search_pattern1);

      var search_pattern2 = ejs_static.path.join(ejs_static.options.path_to_layouts, '**', key, 'index' + ejs_static.options.file_extension);
      grunt.log.debug('search pattern2 is ' + search_pattern2);

      var search_pattern3 = ejs_static.path.join(ejs_static.options.path_to_layouts, '**', key, 'index.ejs');
      grunt.log.debug('search pattern3 is ' + search_pattern3);

      var path_to_layout = grunt.file.expand(search_pattern1, search_pattern2, search_pattern3);

      // if exactly one path to layout is returned, return that path
      if (path_to_layout.length === 1) {

        grunt.log.debug('PATH TO LAYOUT is ' + path_to_layout);
        return path_to_layout;

      // if more than one path to layout is returned, throw error
      } else if (path_to_layout.length > 1) {

        var multiple_layout_paths = "";

        Object.keys(path_to_layout).forEach(function(key) {
          multiple_layout_paths += path_to_layout[key] + '\n';
        });

        grunt.fail.warn('More than 1 path to layout file was not found for key: ' + key + 
                        '\nThe paths found were: \n' + multiple_layout_paths + 
                        '\nResolve in the project dir structure and/or data file\n');

      // if no path to layout is returned, throw error
      } else {
        grunt.fail.warn('path to layout file was not found for key: ' + key);
      }

    }
    // end search the layouts dir for a dir or file that matches key

    // generate path to layout
    function path_to_layout_generator(key, data_object) {

      // if path_to_layout exists
      if (data_object[key].path_to_layout) {

        return data_object[key].path_to_layout;

      // if a layouts dir is specified
      } else if (ejs_static.options.path_to_layouts) {

        return search_layouts_dir(key, ejs_static);

      } else {
        grunt.fail.warn('A value for path_to_layout is required, please specify in data file for key: ' + key);
      }      

    }
    // end generate path to layout

    // test for path_to_layout value for key in data.json
    function path_to_layout_validator(key, data_object) {

      var path_to_layout = path_to_layout_generator(key, data_object);

      if (path_to_layout) {
        // data and layout have been validated, so start create file process
        ejs_static.create_file(key, data_object, path_to_layout, ejs_static);
      } else {
        grunt.log.debug('file NOT CREATED for key: ' + key);
      }

    }
    // end test for path_to_layout value for key in data.json

    // 
    // END PRIVATE FUNCTIONS

  },
  // end parse data

  // prepare data for rendering
  // this combines global data, page data from pages declaration json file, and any additional data from different json files
  prepare_data: function(key, data_object, path_to_layout, ejs_static) {

    // get the data for this file 
    var this_page_data = data_object[key],
        grunt = ejs_static.grunt;

    // add any additional data specified in pages declaration json file
    if (this_page_data.path_to_data) {

      grunt.log.debug(this_page_data.path_to_data);

      data_type_router(key, this_page_data, this_page_data.path_to_data);

    }

    // set the base dir for includes
    // tj uses filename to set base dir for includes in ejs.js
    // which make the include relative to the file
    // see resolveInclude() in visionmedia/ejs/lib/ejs.js
    this_page_data.filename = path_to_layout;
    grunt.log.debug('THIS DATA FILENAME IS ' + this_page_data.filename);

    return this_page_data;

    // PRIVATE FUNCTIONS
    // 

    // route data based on data type (string, object, or array)
    function data_type_router(key, data_object, data_item) {

      grunt.log.debug('data_type_router(): key is ' + key);

      // if path_to_data is a string 
      if (typeof data_item === 'string') {

        process_string_data(key, data_object, data_item);

      // if path_to_data is an object, get the data for only the specified value
      // http://stackoverflow.com/questions/8834126/how-to-efficiently-check-if-variable-is-array-or-object-in-nodejs-v8
      } else if (Object.getPrototypeOf(data_item) === Object.prototype) {

        grunt.log.debug('data_type_router(): data item is an object instead of required string or array');

      // if path_to_data is an array, get the specified data for each item in the array
      } else if (Array.isArray(data_item)) {

        process_array_data(key, data_object, data_item);

      } else {
        grunt.fail.warn('prepare_data(): data type error');
      }

    }
    // end route data based on if data is a string, object, or array

    // function process_string_data(key, data_object, data_item, ejs_static) {
    function process_string_data(key, data_object, data_item) {

      grunt.log.debug('the data item is a string');

      // add the data to the data_object
      data_object[key] = grunt.file.readJSON(data_item);

    }

    // function process_array_data(key, data_object, data_item, ejs_static) {
    function process_array_data(key, data_object, data_item) {

      grunt.log.debug('the data item is an array');

      data_item.forEach(function(path_to_data) {

        // if path_to_data is a string
        if (typeof path_to_data === 'string') {

          // get the filename to use as key when data added to data_object
          var the_filename = ejs_static.path.basename(path_to_data, '.json');

          grunt.log.debug('the filename is ' + the_filename);

          // add the data to the data_object
          data_object[the_filename] = grunt.file.readJSON(path_to_data);

        // if path_to_data is an object
        } else if (Object.getPrototypeOf(path_to_data) === Object.prototype) {

          Object.keys(path_to_data).forEach(function(the_key) {

            // get the filename to use as key when data added to data_object
            var the_filename = ejs_static.path.basename(the_key, '.json');

            var this_data = grunt.file.readJSON(the_key);

            var this_value = path_to_data[the_key];

            // add the data to the data_object
            data_object[the_filename] = this_data[this_value];

            grunt.log.debug('Object in an Array is ' + JSON.stringify(data_object, null, 2));

          });

        } else {
          grunt.fail.warn('prepare_data(): data type error');
        }

      });

    }

    // 
    // END PRIVATE FUNCTIONS      

  },
  // end prepare data for rendering

};

